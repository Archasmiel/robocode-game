Robo-Stars. Створення проєкту. URP. New Input System.

Знайомимось із поняттям "конвеєр рендерінгу". 
Вчимось використовувати Universal render pipeline в Unity. 
Вчимось застосовувати нову систему вводу Unity. 
Повторюємо, як працюють анімації та контролер анімацій в Unity. 
Вчимось імпортувати анімації з інтернет-ресурсу mixamo. 
На основі отриманих знань створюємо ігровий рівень та анімованого гравця.

Діти мають знати: 
Основи Universal Render Pipeline. 
Принцип роботи конвеєра рендерингу. 
Принципи роботи в URP за допомогою Shader Graph. 
Призначення модуля Post Processing. 
Відмінності нової системи вводу Unity та старої. 

Вміти: 
Встановлювати та налаштовувати пакети Input System, DOTween, Photon Network через Package Manager. 
Створювати Action Maps у новій системі вводу Unity для різних дій персонажа. 
Підключати і налаштовувати сервіс Photon Network для мультиплеєрних ігор. 
Використовувати DOTween для налаштування анімаційних переходів у UI інтерфейсі.



Lesson 17 (1-24) [1-15]
Lesson 18 (25-...) [16-...]

1) Створити проєкт з заготвки - 3D Sample Scene (URP)
2) Видаляємо все з папки Scenes та файл Readme
3) Зайти в Unity Asset Store (через браузер і в профіль Юніті)
    скачати пакет DOTween (https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676)
    скачати PUN 2 (https://assetstore.unity.com/packages/tools/network/pun-2-free-119922)
    встановити пакет Input System через звичайні пакети Юніті
    в кінці натиснути Yes для цього пакету та не зберігати сцену яку видалили
4) налаштувати Input System
    Edit -> Project Settings -> Player -> Other Settings
    Configuration -> Active Input Handling (над групою Mac Confuguration - мають бути три пусті поля)
5) додати пакет DOTween через Package Manager
    в кінці має бути панель з кнопкоб якщо все правильно
    в ній натискаємо кнопку, після неї кнопку Setup
    вибираємо лише UI і натискаємо Готово
6) додати до проєкту PUN 2 через Package Manager
    створюємо собі на сайті новий застосунок фотону
    копіюємо код застосунку, вставляємо в поле "Appid or Email"
    натискаємо Готово
    -------------
    логінимось на сайті, зверху справа вибираємо Dashboard
    Create New App -> тип обов'язково Pun -> назва яку завгодно -> натискаємо Create
    в відкритому дешборді шукаємо назву яку створили -> Manage
    під великим надписом на новій сторінці Manage {NameOfApp} шукаємо наш AppId
7) встановлюємо пакет для проекту з скриптами для фотону
    знаходяться нові файли в папці !!!!! Script, не Scripts
    нова сцена з лоббі в Scenes
8) відкрити нову сцену з пакету
    імортувати текстмешпро і закрити вікно
    Extras & Examples не потрібні !!!
9) знаходимо на сцені EventSystem і побачимо справа великий червоний значок
    натичкаємо під ним на кнопку, щоб замінити систему вводу на нову, яку додавали
10) кнопки в меню мають працювати коректно та підключатися до сервера
11) робимо арену в блендер (досить довго), або імпортуємо пакетом/архівом готову(швидко)
    робимо нову сцену, зберігаємо лоббі
    додаємо на 0,0,0 нашу арену - позиція
    розпаковуємо з заготовки, ПКМ по карті -> Prefab -> Unpack/UnpackCompletely
    розміри ставимо 4,4,4
12) необов'язково, але можна створити новий матеріал рівню з ареною
    ще не вистачає MeshCollider для арени
    розкриваємо арену, і до всіх GameObject всередині додаємо MeshCollider
13) натискаємо на об'єкт арени і робимо його Static
    після цього нажимаємо Yes, for all
    сцена не рухається, тому так можемо зробити
14) знаходмо персонажа на сайті Mixamo (https://mixamo.com/)
    вибираємо перса, додаємо анімацію Idle
    качаємо в двох форматах результат - FBX for Unity, Collada(.dae)
    перший буде моделькою, другий архівом
    модельку закидаємо в папку в юніті (з назвою героя)
    з архіву беремо лише папку textures і вставляємо в папку в юніті (з назвою героя)
15) у файлу модельки .fbx 
    міняємо параметр в Rig
    Generic -> Humanoid -> Apply
    міняємо параметри в Animation
    Loop Time ставимо галочку
    Root Transform Rotation -> Bake Into Pose ставимо галочку
    Root Transform Position (Y) -> Bake Into Pose ставимо галочку

16) качаємо модельки Run + Walk і так само налаштовуємо як у 15)
17) створюємо папку ActionMaps 
    створюємо файл Input Actions з назвою PlayerInput
18) є всього три зони (зліва, посередині та справа) у PlayerInput
    зліва робимо нову карту CharacterControls 
    (!!! перевіряйте назву, бо в коді буде скрипт з такою назвою)
    посередині додаємо Actions як на слайдах
    (!!! в нових версіях перейменували Composite, тепер він Add Up/Down... Composite)
19) додати ще групу, але для стрілок
20) додати дію Run (зелена)(actionType=Button, bind=LeftShift)
21) додати всі дії з слайдів
    та натиснути Save Asset !!!
22) вибираємо наш ассет з юніті, шукаємо в інспекторі
    Generate C# Class -> Apply
23) на сцені робимо пустий об'єкт Player
    позиція - 0,0,0
    закидуємо в нього всередину модельку AAAAA@Idle (мали скачати у форматі FBX For Unity)
    розпаковуємо, перейменовуємо в Render (це буде лише картинка-рендер персонажа)
    до Render додаємо CharacterController
    якщо є Animator Controller, додаємо, якщо ні створюємо CharacterAnimatorController
    засовуємо до аніматора в Render
24) додаємо AAAA@Idle до аніматора
    додаємо параметри bool - isWalk та isRun
25) додаємо Sub Machine State, назва Movement (перейменовування в інспекторі)
26) додаємо переходи як на слайді і їх налаштування
27) створюємо скрипт PlayerController, вішаємо на Render
    пишемо код (увага на назву нашого Action Input'a)
28) додаємо на Render CharacterController, налаштовуємо його колайдер

    дивіться на анімації, бо іноді буває, що вона йде на сайті прямо а в юніті вбік
    в Root Transform Rotation міняємо "Based on..." на "Original"



(завд1) додати на персонажа матеріал (якщо все зробили як у гайді, то він вже є)
    якщо немає текстури подивіться момент 14)
(завд2) додати анімацію присідання для двох дій - коли стоїть та коли йде
(завд3) зробити переходи між анімаціями без і з присядом
(завд4) зробити зміну колайдера при присяді



швидкість на жаль в даному вводі не дається постійно, 
не потрібно множити вектор currentMovement, треба зробити метод що видає новий вектор

private Vector3 SpeedControl(Vector3 move) {
    float speed = normalSpeed;
    if (isRun) {
        speed = runSpeed;
    }
    else if (isCrouch) {
        speed = crouchSpeed;
    }

    return new Vector3(move.x * speed, move.y, move.z * speed);
    // не множимо у
}



зробити колайдер краще присяд через два стани - поточний і старий

private void CrouchCollider() {
    if (prevCrouch && !isCrouch) {
        controller.center = CENTER_NORMAL;
        controller.height = HEIGHT_NORMAL;
    }
    else 
    if (!prevCrouch && isCrouch) {
        controller.center = CENTER_CROUCH;
        controller.height = HEIGHT_CROUCH;
    }
}



